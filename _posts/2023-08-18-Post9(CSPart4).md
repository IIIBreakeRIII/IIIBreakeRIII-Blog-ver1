---
layout: post
title: CS 부수기 - 알고리즘 (탐색) 편
description: Github Blog CS Computer-Science Algorithm Interview Study
featuredImage: null
image: null
tags: Develop Developer Student CS Computer-Science Interview Study Algorithm
categories: Study CS
date: '2023-08-18 20:00:00'
img: ''
---
<br>

> CS 부수기 - 알고리즘 (탐색) 편

<br>
<h3>0. 알고리즘이란</h3>
<hr>

드디어, 코딩의 꽃 알고리즘으로 오게 되었다. 
<br><br>
**알고리즘(Algorithm)**의 정의는 위키피디아에 따르면 다음과 같다.
<br><br>

> **Algorithm** : 국어로는 셈법이라고도 하며 수학, **컴퓨터 과학**, 전산 언어학 등에서 **문제 해결 방법을 정의한 단계적 절차**이자 **문제 해결을 위한 동작들의 모임**

<br>
이렇게 정의된다. 
<br><br>
우리가 전공하는 컴퓨터에서의 알고리즘은, 크게 **`탐색`**과 **`정렬`**이 있다.
<br>
조금 더 세부적으로 뻗어나가면 `완전 탐색`, `그리디(Greedy, 탐욕법)` 알고리즘, `최단 경로(Dijkstra)` 등이 있다.
<br><br>
그 중 오늘은 탐색 알고리즘부터 알아보자.

<br>
<h3>1. 탐색 알고리즘</h3>
<hr>

`탐색 알고리즘`은 영어로는 `Searching Algorithm`이라고 하며 정의는 다음과 같다.
<br><br>

> 많은 자료들 중 **원하는 자료**를 찾아내는 방법

<br>

이러한 탐색 알고리즘은 크게 2가지의 형태로 나누어진다.
<br><br>

* 정렬되지 않은 리스트에서의 탐색 : `순차 탐색`
* 정렬된 리스트에서의 탐색 : `이진 탐색`, `색인 순차 탐색`

<br>

탐색 알고리즘의 대표적인 알고리즘은 **`순차 탐색`**, **`이진 탐색`**, **`색인 순차 탐색`**이 있는데, 각각의 알고리즘들은 위의 경우로 해당된다.
<br><br>
그렇다면 먼저 순차 탐색 알고리즘부터 코드와 같이 리뷰하겠다.

<br>
<h3>2. Sequential Search Algorithm</h3>
<hr>

순참 탐색, Sequential Search는 말 그대로 *처음부터 끝까지 다 보는 것* 을 의미한다.
<br>
때문에 선형 탐색이라고 부르기도 한다.
<br><br>
예를 들어 아래 그림과 같이 어느 한 리스트에 원소가 쭉 나열되어 있다고 가정하자.
<br>

![순차 탐색](https://github.com/IIIBreakeRIII/Data-Structure/assets/89850286/24896e74-6cc2-44da-8b21-d8aef9c81c92)

만약에 필자가 `(4)번` 속성을 찾고 싶다면, 순차 탐색의 경우 `(1)번`부터 `(2)번`, `(3)번`을 거쳐 도달하는 형태이다.
<br><br>
이러한 특성 때문에 순차 탐색의 경우 리스트가 정렬되어 있지 않아도 탐색이 가능하다.
<br><br>
코드를 통해 알아보자.
<br><hr>

``` c
// 순차 탐색

#include <stdio.h>
#define MAX_SIZE 100
// List 선언
int list[MAX_SIZE];

// 처음과 끝 숫자를 받아 리스트로 만들어줌
int make_list(int first, int last) {
    int index = 0;
    // loop 돌며 리스트 속성 추가
    for (int i = first; i <= last; i++) {
        list[index] = i;
        index++;
    }
    return 0;
}

// 순차 탐색 알고리즘
int linear_search(int key) {
    int index;
    // index 0부터 각 index의 속성이 찾고자 하는 값(key)과 같은지 확인
    for (index = 0; index <= MAX_SIZE; index++) {
        // 같을 경우 break로 loop 정지
        if (list[index] == key) {
            printf("Index of %d : No.%d\n", key, index);
            break;
        }
    }
    // 값이 존재하지 않을 경우 -1 반환
    return -1;
}

int main() {

    make_list(1, 10);
    linear_search(4);

    make_list(50, 128);
    linear_search(88);

}
```
<hr>
복잡한 코드는 아니다.
<br><br>
리스트를 생성하고, 0번 인덱스부터 값을 비교하며 찾고자 하는 값이 나왔을 때 그 인덱스를 반환해주는 형태이다.
<br><br>
파이썬으로 작성하면 다음과 같다.
<hr>

``` python
# 순차 탐색

# 리스트와 찾고자 하는 값을 parameter로 받음
def linear_search(num_list, key):
    # loop를 돌며 원하는 값(key)을 가르키는 index를 반환
    for i in range(len(num_list)):
        if num_list[i] == key:
            return i + 1 
    # 원하는 값이 없을 경우 False 반환
    return False

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(linear_search(numbers, 6))
print(linear_search(numbers, 20))
```
<hr>
순차 탐색의 시간 복잡도는 다음과 같다.

<h4>  (1 + 2 + 3 + 4 + ... + n) / n = (n + 1) / 2 </h4>
{: .text-center}
<br>
즉, 탐색에 실패한다는 가정 하에 `n번`반복하기 때문에 평균 **`O(n)`**의 시간 복잡도를 가지게 된다.

<br>
<h3>3. Binary Search Algorithm</h3>
<hr>

이진 탐색, Binary Search은 찾는 값이 있는 리스트를 반으로 쪼개 찾는 값이 왼쪽 리스트에 속하는지 오른쪽 리스트에 속하는지 비교하며 탐색하는 방법이다.
<br><br>
이러한 이진 탐색의 특성으로 이진 탐색은 정렬되어 있는 리스트에서 사용하는 특성을 가지게 된다.
<br><br>
그림으로 나타내면 다음과 같다.
<br>

![이진 탐색](https://github.com/IIIBreakeRIII/Data-Structure/assets/89850286/6e70ef20-49db-4ad3-b199-df4a1b638900)

`(1)번`부터 `(7)번`까지 리스트가 있다고 가정하자.
<br><br>
필자가 찾고자 하는 값은 `(1)번`이다.
<br>
그렇다면, `(1)번` ~ `(7)번`의 속성에서 가장 가운데에 있는 속성은 `(4)번`가 된다.
<br>
`(1)번`은 `(4)번`보다 작으므로 `(1)번` ~ `(3)번`까지의 리스트에서 다시 비교한다.
<br>
마찬가지로 송성들 중 가장 가운데는 `(2)번`이고, `(1)번`은 `(2)번`에 비해 작으므로 다시 `(1)번`으로 리스트를 쪼갠다.
<br><br>
이렇게 최종적으로 `(1)번` 속성을 찾을 수 있다.
<br><br>
코드를 통해 알아보자.
<hr>

``` c
// 이진 탐색

#include <stdio.h>
#include <time.h>

#define MAX_ELEMENTS 10000000L

// 리스트와 몇 번 쪼갰는지 확인을 위한 count 변수 생성
int list[MAX_ELEMENTS];
int count = 0;

// 처음과 끝 숫자를 받아 리스트 만들어줌
int make_list(int first, int last) {
    int index = 0;
	// loop 돌며 속성 추가
    for (int i = first; i <= last; i++) {
        list[index] = i;
        index++;
    }
    return 0;
}

// 이진 탐색 알고리즘
int search_binary(int key, int low, int high) {
    // 리스트의 가운데를 가르킬 값
    int middle;

    if (low <= high) {
        // 처음과 끝을 2로 나누어 가운데 값 만들어냄
        middle = (low + high) / 2;
        // 찾는 값(key)가 가운데 값과 같을 경우 count 세고 반환
        if (key == list[middle]) {
            count++;
            printf("Search Count = %d", count);
            return middle;
        // 찾는 값이 가운데 값보다 작을 경우
        } else if (key < list[middle]) {
            count++;
            return search_binary(key, low, middle - 1);
        // 찾는 값이 가운데 값보다 클 경우
        } else {
            count++;
            return search_binary(key, middle + 1, high);
        }
    }
    // 값이 없을 경우 -1로 반환
    return -1;
}

int main() {
    make_list(0, 10);
    search_binary(4, 0, 10);
}
```

<hr>
